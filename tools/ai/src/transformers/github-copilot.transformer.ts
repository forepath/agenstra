import type { AgenstraContext, ComponentType, ToolOutput } from '../types';
import { BaseTransformer } from './base.transformer';

const GITHUB_DIR = '.github';

/**
 * Path-specific instructions: NAME.instructions.md with frontmatter applyTo (glob).
 * applyTo uses glob syntax; "**" = all files. Optional excludeAgent: "code-review" | "coding-agent".
 * @see https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions
 */
function withApplyToFrontmatter(content: string, applyTo = '**'): string {
  const escaped = applyTo.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return `---
applyTo: "${escaped}"
---

${content}`;
}

export class GithubCopilotTransformer extends BaseTransformer {
  readonly name = 'github-copilot' as const;

  canUseComponent(component: ComponentType): boolean {
    return component !== 'skills';
  }

  needsFallbackMerge(): ComponentType[] {
    return ['skills'];
  }

  transform(context: AgenstraContext): ToolOutput {
    const out = new Map<string, string>();

    const mainInstructions = buildCopilotInstructions(context);
    out.set(`${GITHUB_DIR}/copilot-instructions.md`, mainInstructions);

    // Group rules by globs: rules with globs (except ['**']) get path-specific instruction files (applyTo autogenerated from globs)
    const rulesByGlobsKey = new Map<
      string,
      { applyTo: string; rules: Array<{ name: string; entry: import('../types').RuleEntry }> }
    >();
    const isRepoWide = (g: string[] | undefined) => g != null && g.length === 1 && g[0] === '**';
    for (const [name, entry] of Object.entries(context.rules)) {
      if (name.startsWith('_')) continue;
      const ruleEntry = typeof entry === 'string' ? { content: entry } : entry;
      const globs = ruleEntry.globs;
      if (globs != null && globs.length > 0 && !isRepoWide(globs)) {
        const key = [...globs].sort().join(',');
        const applyTo = globs.join(', ');
        if (!rulesByGlobsKey.has(key)) {
          rulesByGlobsKey.set(key, { applyTo, rules: [] });
        }
        rulesByGlobsKey.get(key)!.rules.push({ name, entry: ruleEntry });
      }
    }

    for (const { applyTo, rules } of rulesByGlobsKey.values()) {
      const parts: string[] = [`# Path-specific instructions\n\n`, `Apply to: \`${applyTo}\`\n\n`];
      for (const { name, entry } of rules) {
        parts.push(`## ${name}\n\n`, entry.content, '\n\n');
      }
      const safeName = applyTo
        .replace(/[^a-zA-Z0-9-,]/g, '-')
        .replace(/-+/g, '-')
        .toLowerCase();
      out.set(
        `${GITHUB_DIR}/instructions/${safeName}.instructions.md`,
        withApplyToFrontmatter(parts.join(''), applyTo),
      );
    }

    const mergedSkills = context.rules['_merged_skills'];
    if (mergedSkills != null) {
      const content = typeof mergedSkills === 'string' ? mergedSkills : mergedSkills.content;
      out.set(`${GITHUB_DIR}/instructions/skills.instructions.md`, withApplyToFrontmatter(content));
    }

    const agentsContent = buildAgentsFallback(context);
    out.set(`${GITHUB_DIR}/instructions/agents.instructions.md`, withApplyToFrontmatter(agentsContent));

    return out;
  }
}

function buildCopilotInstructions(context: AgenstraContext): string {
  const parts: string[] = ['# Repository instructions\n', 'Generated from .agenstra context.\n\n'];

  for (const [name, entry] of Object.entries(context.rules)) {
    if (name.startsWith('_')) continue;
    const ruleEntry = typeof entry === 'string' ? { content: entry } : entry;
    // Include rules without globs, empty globs, or globs ['**'] (alwaysApply) in main repository-wide instructions
    const globs = ruleEntry.globs;
    const repoWide = globs == null || globs.length === 0 || (globs.length === 1 && globs[0] === '**');
    if (repoWide) {
      parts.push(`## ${name}\n\n`, ruleEntry.content, '\n\n');
    }
  }

  return parts.join('');
}

function agentBody(config: { description?: string; body?: string }): string {
  const bodyContent = (config.body as string)?.trim();
  if (bodyContent) return bodyContent;
  return (config.description ?? '').trim() || '';
}

/** GitHub Copilot does not support subagents; emit only primary agents. */
function buildAgentsFallback(context: AgenstraContext): string {
  const lines = ['# Agents\n'];
  for (const [id, a] of Object.entries(context.agents)) {
    const config = a as { name?: string; description?: string; body?: string };
    const name = config.name ?? id;
    lines.push(`## ${name}\n\n**ID:** ${id}\n\n`);
    const body = agentBody(config);
    if (body) lines.push(body, '\n\n');
  }
  lines.push('\n');
  lines.push('# Subagents\n');
  for (const [id, a] of Object.entries(context.subagents)) {
    const config = a as { name?: string; description?: string; body?: string };
    const name = config.name ?? id;
    lines.push(`## ${name} (subagent)\n\n**ID:** ${id}\n\n`);
    const body = agentBody(config);
    if (body) lines.push(body, '\n\n');
  }
  return lines.join('\n');
}
